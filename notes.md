We want to create a generalized TTP on a process of analyzing malware; not TTP for adversary. This is creating a defensive TTP "handbook"
Look at books and follow the books that LCDR Slack gives us

WHAT ARE WE GOING TO DO DIFFERENT??
  -Check what recent research has done, and what questions they still have unanswered.

OpenSource Tools
https://github.com/fireeye/capa

Testing



# Problems/Challenges:
*  Extract Data from binaries
  *  Solution
    * Use Ghidra API to extract Pseudo-C from binary
    * Use Ghidra API to extract metadata from binary
    * Use native Linux static analysis tools to extract binary metadata
* Compile data into parsable format for ML tools
  * Solution
    * Output data via python to csv, txt
    * Gridra output -> tuples, arrays that can be integrated with Dylan’s code
    * Code2vec, (code2vec: Learning Distributed Representations of Code (technion.ac.il) - Employ Natural Language Processing in modeling code (pseudo c) as vectors which a ML model can be trained on.
* Obtain Data for training model and testing
  * Solution
    * Pull from open source repositories of known and categorized malware
    * Reach out to SME for samples
    * Reach out to ITSD
    * NCDOC?
* Account for differences in languages
  * I.e. C vs. Go compile differently, handle strings differently(Reverse Engineering Go Binaries with Ghidra - CUJO AI)
  * Solution
    * If we implement ML, it may be possible to stay language agnostic, since we will be searching for similar patterns, not defined code.
* Computing power for processing data
  * Millions of binary samples
  * Running each one through ghidra
  * solution
    * Possible use of USNA GRACE Supercomputer

# Current Status/Progress:

### Eric
* Analyzing binary files via ghidra
* Currently able to pull out pseudo c from binary.
* Goal:
  * Pull out as much data as possible from each binary, arrange into parsable format
    * Need to figure out how, csv probably won’t cut it, maybe xml? Easier to display and read, better for complicated datasets
    * Possibly arrange as
      * \<binary>
        * \<hexdump>
        * \<sections>
          * \<name>
          * \<size>
          * \<data>
        * \<functions>
          * \<name>
          * \<size>
          * \<PCode>
          * \<pseudoCode>
* Researching how we could implement MLonCode:
  * code2vec
  * code2seq
