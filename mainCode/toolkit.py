#REQUIRED MODULES
import sys
import argparse
import os
import subprocess

#CLASSES? 
''' Would it be beneficial to have a ransomware class as a means of containing the object within a database file
that when printed could output all of its relevant information by manipulating object__str__()?''' 

class RansomWare(): #do we want to create objects of the ransomware? is it useful at all?
    def __init__(self, hashes, reasons):
        pass 

#FUNCTION DEFINITIONS

''' Main should not have everything within it, but instead call out to other functions in order to perform the bulk
of the program.''' 

def main():
    parser = argparse.ArgumentParser(prog=sys.argv[0],usage="toolkit.py [-h][-q, --quick] -i, --input <input file> -o <output file>")
    parser.add_argument('-q', "--quick", action='store_true',help="Enable quick analysis\n") #what are we defining as "quick analysis"? 
    parser.add_argument('-i','--infile', nargs='?', type=str, required=True, help = "Input the file to analyze\n", default=sys.stdin)
    parser.add_argument('-o','--outfile', nargs='?', type=str, required=True, help="Name an output file to be written to your current direction with an overview of the file and it's contents.")
    #what other arguments do we want available to the user? do we just do quick analysis/full analysis? what is included in both of those?
    args = parser.parse_args()
    print(args)
    if args.quick: 
        with open(f"{args.outfile}", 'w') as f:
            print("Quick Analysis Enabled")
            cmdStrings = ['file ', 'strings ','nm -l ', 'objdump -p '] # enter the commands we want to run natively in Linux
            nativeCommandGenerator(cmdStrings, args, f)

'''
With the nativeCommandGenerator() function, we are only interested in using native Linux commands that are going to be used for general static binary analysis. 
Some questions to answer:
1. What commands are most important for something like this? 
2. How can we parse the information within the output to actually be something useful that someone would want to use operationally?
3. If someone doesn't have one of the tools loaded on their machine for this purpose, how can we create a dependency / makefile that would ensure all commands
are available on the machine and won't run an error / crash our program? 
4. Need to verify that all commands that we use are STATIC ONLY, absolutely no dynamic running of the programs (yet?). 
'''

def nativeCommandGenerator(cmdStrings, args, fileToWrite):
    for cmds in cmdStrings:
        print(cmds)
        output = subprocess.check_output(cmds + f"{args.infile}", shell=True, text=True)
        fileToWrite.write(output + '\n')
        if (cmds == 'file ' and 'ELF' in output):
            elfheader = subprocess.check_output('readelf -h --dyn-syms -s -R .rodata ' + f"{args.infile}", shell=True, text=True)
            fileToWrite.write(elfheader + '\n')
        elif (cmds == 'objdump -p '):
            libDep = subprocess.check_output(cmds + f"{args.infile} | grep NEEDED", shell=True, text=True)
            fileToWrite.write(libDep + '\n')

''' ransomwareCheck() should be used as a means of checking the output file for any suspicious calls to functions, function names, 
or otherwise unusual program execution that could be likened to ransomware. For example, calls to taskkill.exe, sc.exe, cipher.exe, 
wevtutil, fsutil.exe, vsadmin.exe, wbadmin.exe, bcdedit.exe, regedit.exe, schtasks.exe, calls to C&C servers, hash functions etc.'''

def ransomwareCheck(outputfile):
    pass 


if __name__=='__main__':
    main()
