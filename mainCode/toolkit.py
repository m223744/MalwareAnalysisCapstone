# REQUIRED MODULES
import sys, argparse, os, subprocess, hashlib, r2pipe

# GLOBAL VARIABLES
''' We're going to be reading the Binary in 64kb chunks in order to preserve memory allocations.'''
BUF_SIZE = 65536


# CLASSES

class Binary:
    """
    The Binary class object is a way to create unique objects for each binary that we analyze. This will contain
    hashes of the binary
    """

    def __init__(self, binary):
        self.binaryFile = binary
        self.fullDict = {}
        self.md5 = None
        self.sha1 = None
        self.sha256 = None
        self.getHashes()

    def __str__(self):
        print(f"\nProvided Binary File: {self.binaryFile}\n")
        for key, value in self.fullDict.items():
            print(f"{key}: " + ''.join(str(value)) + "\n")
        return ''

    def getHashes(self):
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        with open(self.binaryFile, 'rb') as f:
            while True:
                data = f.read(BUF_SIZE)
                if not data:
                    break
                md5.update(data)
                sha1.update(data)
                sha256.update(data)
            self.md5 = md5
            self.sha1 = sha1
            self.sha256 = sha256
            self.fullDict['md5'] = self.md5.hexdigest()
            self.fullDict['sha1'] = self.sha1.hexdigest()
            self.fullDict['sha256'] = self.sha256.hexdigest()


# FUNCTION DEFINITIONS


def main():
    """ Main should not have everything within it, but instead call out to other functions in order to perform the bulk
    of the program."""
    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('-i', '--infile', nargs='?', type=str, required=True, help="Input the file to analyze",
                        default=sys.stdin)
    parser.add_argument('-o', '--outfile', nargs='?', type=str, required=True,
                        help="Name an output file to be written to a new directory in within your current working "
                             "path which contains an overview of the file and it's contents.")
    args = parser.parse_args()
    binaryObj = Binary(args.infile)
    # if the file the user is supplying isn't in the current directory, need to
    # maintain a naming convention while writing the output file to a new
    # directory related to the Binary itself.
    if len(args.infile.split("/")) != 1:
        file = args.infile.split("/")[-1]
    filename = f"../analyizedFiles/{file}/{args.outfile}"
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, 'w') as f:
        cmdStrings = ['file ', 'nm --extern-only ', 'objdump ']  # enter the commands we want to run natively in Linux
        nativeCommandGenerator(cmdStrings, args, f, binaryObj)


def nativeCommandGenerator(cmdStrings, args, fileToWrite, binaryObj):
    fileToWrite.write('md5: ' + str(binaryObj.fullDict['md5']) + '\n')
    fileToWrite.write('sha1: ' + str(binaryObj.fullDict['sha1']) + '\n')
    fileToWrite.write('sha256: ' + str(binaryObj.fullDict['sha256']) + '\n\n')
    for cmds in cmdStrings:
        if cmds == 'file ':
            if 'ELF' in subprocess.run([f"{cmds}{args.infile}"], text=True):
                fileToWrite.write(cmds + '\n\n')
                output = subprocess.check_output('readelf -h --dyn-syms ' + f"{args.infile}", shell=True)
                binaryObj.fullDict[cmds] = output
                fileToWrite.write(output + '\n\n')
            else:
                output = subprocess.check_output(f"{cmds}{args.infile}", shell=True)
                binaryObj.fullDict[cmds] = output
                fileToWrite.write(output + '\n\n')
        elif cmds == 'objdump ':
            fileToWrite.write(cmds + '\n\n')
            fullCmd = f"objdump -Mintel -d {args.infile} | grep call"
            output = subprocess.check_output(fullCmd, shell=True)
            binaryObj.fullDict[cmds] = output
            fileToWrite.write(output + '\n\n')
            fullCmd = f"objdump -Mintel -s -j .rodata {args.infile}"
            output = subprocess.check_output(fullCmd, shell=True)
            binaryObj.fullDict[cmds] += output
            fileToWrite.write(output + '\n\n')
        else:
            fileToWrite.write(cmds + '\n\n')
            output = subprocess.check_output(cmds + f"{args.infile}", shell=True)
            binaryObj.fullDict[cmds] = output
            fileToWrite.write(output + '\n')
    radare = r2pipe.open(args.infile, flags=['-2'])
    radare.cmd('aaaa')
    # print(radare.cmd('afl'))
    hrStrings = radare.cmd('Cs')
    fileToWrite.write(hrStrings + '\n')
    binaryObj.fullDict['radare2 Cs'] = hrStrings
    print(binaryObj)


if __name__ == '__main__':
    main()
