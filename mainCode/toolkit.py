# REQUIRED MODULES
import sys, argparse, os, subprocess, hashlib, r2pipe, yara


# import tensorflow


# GLOBAL VARIABLES
''' We're going to be reading the Binary in 64kb chunks in order to preserve memory allocations.'''
BUF_SIZE = 65536


# CLASSES

class Binary:
    """
    03NOV21: Create a Binary "class" that contains a dictionary. Keys = name of the command run against the Binary,
    values = the output of the command. Manipulate __str__ to print pretty ouptut. Define self.___() for specifics to
    the Binary (hash, for example)
    """
    def __init__(self, binary):
        self.binaryFile = binary
        self.fullDict = {}
        self.md5 = None
        self.sha1 = None
        self.sha256 = None
        self.getHashes()

    def __str__(self):
        print(f"\nProvided Binary File: {self.binaryFile}\n")
        for key, value in self.fullDict.items():
            print(f"{key}: " + ''.join(str(value)) + "\n")
        return ''

    def getHashes(self):
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        with open(self.binaryFile, 'rb') as f:
            while True:
                data = f.read(BUF_SIZE)
                if not data:
                    break
                md5.update(data)
                sha1.update(data)
                sha256.update(data)
            self.md5 = md5
            self.sha1 = sha1
            self.sha256 = sha256
            self.fullDict['md5'] = self.md5.hexdigest()
            self.fullDict['sha1'] = self.sha1.hexdigest()
            self.fullDict['sha256'] = self.sha256.hexdigest()

# FUNCTION DEFINITIONS


def main():
    """ Main should not have everything within it, but instead call out to other functions in order to perform the bulk
    of the program."""
    parser = argparse.ArgumentParser(prog=sys.argv[0])
    parser.add_argument('-i', '--infile', nargs='?', type=str, required=True, help="Input the file to analyze",
                        default=sys.stdin)
    parser.add_argument('-o', '--outfile', nargs='?', type=str, required=True,
                        help="Name an output file to be written to a new directory in within your current working "
                             "path which contains an overview of the file and it's contents.")
    args = parser.parse_args()
    # what other arguments do we want available to the user? Should this just be an all encompassing toolkit? Probably..
    binaryObj = Binary(args.infile)
    # if the file the user is supplying isn't in the current directory, need to
    # maintain a naming convention while writing the output file to a new
    # directory related to the Binary itself.
    if len(args.infile.split("/")) != 1:
        file = args.infile.split("/")[-1]
    filename = f"./{file}/{args.outfile}"
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, 'w') as f:
        cmdStrings = ['file ', 'nm --extern-only ', 'objdump ']  # enter the commands we want to run natively in Linux
        nativeCommandGenerator(cmdStrings, args, f, binaryObj)


def nativeCommandGenerator(cmdStrings, args, fileToWrite, binaryObj):
    '''
    With the nativeCommandGenerator() function, we are only interested in using native Linux commands that are going to be used for general static Binary analysis.
    Some questions to answer:
    1. What commands are most important for something like this? 
    2. How can we parse the information within the output to actually be something useful that someone would want to use operationally?
    3. If someone doesn't have one of the tools loaded on their machine for this purpose, how can we create a dependency / makefile that would ensure all commands
    are available on the machine and won't run an error / crash our program? 
    4. Need to verify that all commands that we use are STATIC ONLY, absolutely no dynamic running of the programs (yet?). 
    '''
    fileToWrite.write('md5: ' + str(binaryObj.fullDict['md5']) + '\n')
    fileToWrite.write('sha1: ' + str(binaryObj.fullDict['sha1']) + '\n')
    fileToWrite.write('sha256: ' + str(binaryObj.fullDict['sha256']) + '\n\n')
    for cmds in cmdStrings:
        if cmds == 'file ':
            if 'ELF' in subprocess.check_output(f"{cmds}{args.infile}", shell=True, text=True):
                fileToWrite.write(cmds + '\n\n')
                output = subprocess.check_output('readelf -h --dyn-syms ' + f"{args.infile}", shell=True, text=True)
                binaryObj.fullDict[cmds] = output
                fileToWrite.write(output + '\n\n')
            else:
                output = subprocess.check_output(f"{cmds}{args.infile}", shell=True, text=True)
                binaryObj.fullDict[cmds] = output
                fileToWrite.write(output + '\n\n')
        elif cmds == 'objdump ':
            fileToWrite.write(cmds + '\n\n')
            fullCmd = f"objdump -Mintel -d {args.infile} | grep call"
            output = subprocess.check_output(fullCmd, shell=True, text=True)
            binaryObj.fullDict[cmds] = output
            fileToWrite.write(output + '\n\n')
            fullCmd = f"objdump -Mintel -s -j .rodata {args.infile}"
            output = subprocess.check_output(fullCmd, shell=True, text=True)
            binaryObj.fullDict[cmds] += output
            fileToWrite.write(output + '\n\n')
        else:
            fileToWrite.write(cmds + '\n\n')
            output = subprocess.check_output(cmds + f"{args.infile}", shell=True, text=True)
            binaryObj.fullDict[cmds] = output
            fileToWrite.write(output + '\n')
    radare = r2pipe.open(args.infile, flags=['-2'])
    radare.cmd('aaaa')
    # print(radare.cmd('afl'))
    hrStrings = radare.cmd('Cs')
    fileToWrite.write(hrStrings + '\n')
    binaryObj.fullDict['radare2 Cs'] = hrStrings
    print(binaryObj)


def ransomwareCheck(outputfile):
    ''' ransomwareCheck() should be used as a means of checking the output file for any suspicious calls to functions, function names, 
    or otherwise unusual program execution that could be likened to ransomware. For example, calls to taskkill.exe, sc.exe, cipher.exe, 
    wevtutil, fsutil.exe, vsadmin.exe, wbadmin.exe, bcdedit.exe, regedit.exe, schtasks.exe, calls to C&C servers, hash functions etc.
    '''
    pass


if __name__ == '__main__':
    main()
