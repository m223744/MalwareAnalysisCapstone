#REQUIRED MODULES
import sys
import argparse
import os
import subprocess

#FUNCTION DEFINITIONS
def main():
    parser = argparse.ArgumentParser(prog=sys.argv[0],usage="toolkit.py [-h][-q, --quick] -i, --input <input file> -o <output file>")
    parser.add_argument('-q', "--quick", action='store_true',help="Enable quick analysis\n")
    parser.add_argument('-i','--infile', nargs='?', type=str, required=True, help = "Input the file to analyze\n", default=sys.stdin)
    parser.add_argument('-o','--outfile', nargs='?', type=str, required=True, help="Optional: name an output file to be written to your current direction with an overview of the file and it's contents.")
    args = parser.parse_args()
    print(args)
    if args.quick:
        with open(f"{args.outfile}.txt", 'w') as f:
            print("Quick Analysis Enabled")
            cmdStrings = ['file ', 'strings ','nm -l ', 'objdump -p '] # enter the commands we want to run natively in Linux
            nativeCommandGenerator(cmdStrings, args, f)


def nativeCommandGenerator(cmdStrings, args, fileToWrite):
    for cmds in cmdStrings:
        print(cmds)
        output = subprocess.check_output(cmds + f"{args.infile}", shell=True, text=True)
        fileToWrite.write(output + '\n')
        if (cmds == 'file ' and 'ELF' in output):
            elfheader = subprocess.check_output('readelf -h --dyn-syms -s -R .rodata ' + f"{args.infile}", shell=True, text=True)
            fileToWrite.write(elfheader + '\n')
        elif (cmds == 'objdump -p '):
            libDep = subprocess.check_output(cmds + f"{args.infile} | grep NEEDED", shell=True, text=True)
            fileToWrite.write(libDep + '\n')



if __name__=='__main__':
    main()
