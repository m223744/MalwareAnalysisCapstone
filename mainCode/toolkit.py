#REQUIRED MODULES
import sys
import argparse
import os
import subprocess
import hashlib

#GLOBAL VARIABLES
''' We're going to be reading the binary in 64kb chunks in order to preserve memory allocations.'''
BUF_SIZE = 65536 



#CLASSES
''' 
03NOV21: Create a binary "class" that contains a dictionary. Keys = name of the command run against the binary, values = the output of the command. 
Manipulate __str__ to print pretty ouptut. Define self.___() for specifics to the binary (hash, for example)
''' 

class binary:
    def __init__(self, binary):
        self.binaryFile = binary
        self.fullDict = {} 
        self.md5 = None
        self.sha1 = None
        self.sha256 = None
        self.getHashes()

    def __str__(self):
        print(f"\n{color.BOLD}Provided Binary File:{color.END} {self.binaryFile}\n")
        for key, value in self.fullDict.items():
            print(f"{color.BOLD}{key}{color.END}: {value}\n")
        return ''

    def getHashes(self):
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        with open(self.binaryFile, 'rb') as f:
            while True:
                data = f.read(BUF_SIZE)
                if not data:
                    break
                md5.update(data)
                sha1.update(data)
                sha256.update(data)
            self.md5 = md5
            self.sha1 = sha1
            self.sha256 = sha256
            self.fullDict['md5'] = self.md5.hexdigest()
            self.fullDict['sha1'] = self.sha1.hexdigest()
            self.fullDict['sha256'] = self.sha256.hexdigest()
        
class color:
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   END = '\033[0m'    

#FUNCTION DEFINITIONS

''' Main should not have everything within it, but instead call out to other functions in order to perform the bulk
of the program.''' 

def main():
    parser = argparse.ArgumentParser(prog=sys.argv[0]) 
    parser.add_argument('-i','--infile', nargs='?', type=str, required=True, help = "Input the file to analyze", default=sys.stdin)
    parser.add_argument('-o','--outfile', nargs='?', type=str, required=True, help="Name an output file to be written to your current direction with an overview of the file and it's contents.")
    args = parser.parse_args()
    #what other arguments do we want available to the user? Should this just be an all encompassing toolkit? Probably.. 
    binaryObj = binary(args.infile)
    with open(f"{args.outfile}", 'w') as f:
        cmdStrings = ['file ', 'strings ','nm --extern-only ', 'objdump -p '] # enter the commands we want to run natively in Linux
        nativeCommandGenerator(cmdStrings, args, f, binaryObj)
    print(binaryObj)

'''
With the nativeCommandGenerator() function, we are only interested in using native Linux commands that are going to be used for general static binary analysis. 
Some questions to answer:
1. What commands are most important for something like this? 
2. How can we parse the information within the output to actually be something useful that someone would want to use operationally?
3. If someone doesn't have one of the tools loaded on their machine for this purpose, how can we create a dependency / makefile that would ensure all commands
are available on the machine and won't run an error / crash our program? 
4. Need to verify that all commands that we use are STATIC ONLY, absolutely no dynamic running of the programs (yet?). 
'''

def nativeCommandGenerator(cmdStrings, args, fileToWrite, binaryObj):
    for cmds in cmdStrings:
        fileToWrite.write(color.BOLD + cmds + color.END + '\n\n')
        output = subprocess.check_output(cmds + f"{args.infile}", shell=True, text=True)
        binaryObj.fullDict[cmds] = output
        fileToWrite.write(output + '\n')
        if (cmds == 'file ' and 'ELF' in output):
            elfheader = subprocess.check_output('readelf -h --dyn-syms -s -R .rodata ' + f"{args.infile}", shell=True, text=True)
            fileToWrite.write(elfheader + '\n\n')
        elif (cmds == 'objdump -p '):

            libDep = subprocess.check_output(cmds + f"{args.infile} | grep NEEDED", shell=True, text=True)
            fileToWrite.write(libDep + '\n\n')

''' ransomwareCheck() should be used as a means of checking the output file for any suspicious calls to functions, function names, 
or otherwise unusual program execution that could be likened to ransomware. For example, calls to taskkill.exe, sc.exe, cipher.exe, 
wevtutil, fsutil.exe, vsadmin.exe, wbadmin.exe, bcdedit.exe, regedit.exe, schtasks.exe, calls to C&C servers, hash functions etc.'''

def ransomwareCheck(outputfile):
    pass 


if __name__=='__main__':
    main()