#!/usr/bin/env python3

# Import csv for parseCsv
import csv

# Image library for generating image representation of binary
from PIL import Image

# Imports for MalwareBazaar api
import requests
import pyzipper
import tempfile





class malSample:
    '''
    Malware Sample class for holding data of each malware sample. To be used when parsing csv file of sample from MalwareBazaar
    '''

    def __init__(self, timeStamp, hash, fileType, signature, tags, reporter, category):
        self.timeStamp = timeStamp
        self.hash = hash
        self.fileType = fileType
        self.signature = signature
        self.tags = tags
        self.reporter = reporter
        self.category = category

    def __str__(self):
        return "Category: " + self.category + "\tSignature: " + self.signature + "\tHash: " + self.hash[0:30] + "..."


def parseCsv(file: str) -> list:
    '''
    Parse the csv file of hashed from malwarebazaar and generate a 'malSample'
    class for each one, containing the hash, category, and metadata of the malware sample
    returns a list of malSample objects
    '''

    samples = []

    with open(file, newline='\n') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            samples.append(
                malSample(row[0], row[1], row[2], row[3], row[4], row[5], row[6]))

    return samples


def getTuples(inBytes: bytes, outputName: str) -> list:
    '''
    Generate a list of tuples containing the bytes as integers
    '''

    size = 65536
    read = 0
    array = []

    for i in range(0, size, 3):
        # Bytes are already sequences of integers, use slicing to get byte objects vs indexing
        byte_list = (inBytes[i:i+1], inBytes[i+1:i+2], inBytes[i+2:i+3]) # Tuple of the bytes
        first = int.from_bytes(byte_list[0], "big") # Convert bytes to integer
        second = int.from_bytes(byte_list[1], "big")
        third = int.from_bytes(byte_list[2], "big")
        rgb_tuple = (first, second, third)
        if len(rgb_tuple) == 3:
            array.append(rgb_tuple)
        read += 1
    
    return array


def getSample(sample: malSample) -> bytes:
    '''
    Get the sample from the malwarebazaar website using the api. 
    Returns byte object of first file found in downloaded and decrypted archive
    '''
    print("Running getSample")
    hash = sample.hash
    category = sample.category

    ZIP_PASSWORD = b'infected'
    headers = {'API-KEY': ''}

    data = {
        'query': 'get_file',
        'sha256_hash': hash,
    }

    response = requests.post('https://mb-api.abuse.ch/api/v1/', data=data, timeout=10, headers=headers, allow_redirects=True)

    if 'file_not_found' in response.text:
        print("Error: file not found")
        return

    else:
        # Create a temporary file which is the downloaded zip
        with tempfile.TemporaryFile('w+b') as tempZip:
            # Write the zip bytes to the temp zip file
            tempZip.write(response.content)
            with pyzipper.AESZipFile(tempZip) as zf:  # Open the zip file
                with zf.read(zf.namelist()[0], pwd=ZIP_PASSWORD) as malwareFileBytes: # Read the first file in the archive and decrypt it
                    print("Downloaded and Unzipped " + zf.namelist()[0])
                    with open(sample.category + "-" + sample.fileType + "-" + sample.hash, 'wb') as malwareFile:
                        malwareFile.write(malwareFileBytes)
                    return malwareFileBytes
                    


samples = parseCsv('./mainCode/MalwareBazaar.csv')


for sample in samples:
    getSample(sample)
    